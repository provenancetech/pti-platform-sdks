/**
 * This file was auto-generated by Fern from our API Definition.
 */

package com.pti.sdk.types;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.pti.sdk.core.ObjectMappers;
import java.lang.Integer;
import java.lang.Object;
import java.lang.String;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

@JsonInclude(JsonInclude.Include.NON_ABSENT)
@JsonDeserialize(
    builder = InvalidRequestError.Builder.class
)
public final class InvalidRequestError implements IManagedError {
  private final Optional<ErrorType> type;

  private final Optional<Integer> code;

  private final Optional<List<String>> errors;

  private final Map<String, Object> additionalProperties;

  private InvalidRequestError(Optional<ErrorType> type, Optional<Integer> code,
      Optional<List<String>> errors, Map<String, Object> additionalProperties) {
    this.type = type;
    this.code = code;
    this.errors = errors;
    this.additionalProperties = additionalProperties;
  }

  @JsonProperty("type")
  @Override
  public Optional<ErrorType> getType() {
    return type;
  }

  /**
   * @return <h1>Error codes descriptions</h1>
   * NO_ERROR(0)
   * INVALID_REQUEST(1000)
   * MIN_INFO_MISSING(1001)
   * MIN_ASSESSMENT_MISSING(1002)
   * ALREADY_IN_PROGRESS(1003)
   * MISSING_WALLET(1004)
   * WALLETS_DIFFERENT_CURRENCY(1005)
   * WALLETS_SAME_CURRENCY(1006)
   * SOURCE_WALLET_DESTINATION_TOKEN_ONLY(1007)
   * ITEM_USD_VALUE_REQUIRED_WHEN_MULTIPLE_ITEMS(1008)
   * INVALID_USER_TAG(1009)
   * MISSING_TRANSACTION_GROUP_ID(1010)
   * DIFFERENT_BUY_SELL_AMOUNT(1011)
   * DIFFERENT_BUY_SELL_CURRENCIES(1012)
   * WALLET_MISSING_NETWORK(1013)
   * PAYMENT_METHOD_TYPE_REQUIRED(1014)
   * AMOUNT_REQUIRED(1015)
   * NO_INTER_CLIENTS_TRANSFERS(2000)
   * CLIENT_CONFIGURATION_ERROR(2001)
   * UNSUPPORTED_OPERATION(2002)
   * COUNTRY_NOT_SUPPORTED(2003)
   * UNSUPPORTED_CURRENCY(2004)
   * UNSUPPORTED_FIAT_CURRENCY(2005)
   * UNSUPPORTED_CRYPTO_CURRENCY(2005)
   * UNSUPPORTED_DEPOSIT_ADDRESS(2006)
   * INVALID_WALLET_PROVIDER(2007)
   * INVALID_WALLET_PROVIDER_CONFIGURATION(2008)
   * NOT_ENOUGH_FUNDS(3000)
   * INVALID_ASSET_OWNERSHIP(3001)
   * FEES_WALLET_NOT_FOUND(3002)
   * REVERT_ONLY_CHARGE_BACK(3003)
   * MISSING_CORRESPONDING_BUY_TRANSACTION(3004)
   * ALREADY_EXISTING_CORRESPONDING_TRANSACTION_PAIR(3005)
   * BUY_TRANSACTION_NOT_SETTLED(3006)
   * FIAT_ONLY(3007)
   * SOURCE_DESTINATION_WALLET(3008)
   * INVALID_SOURCE_CURRENCY(3009)
   * INVALID_DESTINATION_CURRENCY(3010)
   * USD_WALLET_ONLY(3011)
   * NON_CORRESPONDING_USERS_FOR_TRANSACTION(3012)
   * UNSUPPORTED_SOURCE_METHOD(3013)
   * WALLET_REFERENCE_ALREADY_EXISTS(3014)
   * UNABLE_TO_DELETE_WALLET_WITH_NONZERO_BALANCE(3015)
   * WALLET_DELETED(3016)
   * WALLET_LABEL_ALREADY_IN_USE(3017)
   * BANK_ONLY(4000)
   * MISSING_EMAIL_ADDRESS(4001)
   * MISSING_BANK_ACCOUNT_INFORMATION(4002)
   * MISSING_BANK_ACCOUNT_NUMBER_INFORMATION(4003)
   * MISSING_BANK_ACCOUNT_TYPE(4004)
   * FUNDING_FROM_ACH_ONLY(4005)
   * WITHDRAWING_FROM_WALLET_ONLY(4006)
   * WITHDRAWING_TO_ACH_WIRE_ONLY(4007)
   * FUNDING_TO_WALLET_ONLY(4008)
   * MANDATORY_IP_ADDRESS(5000)
   * MANDATORY_EMAIL_ADDRESS(5001)
   * MISSING_CC_INFO(5002)
   * CC_ONLY(5003)
   * UNABLE_TO_PROVIDE_ESTIMATES(6000)
   * FUNDING_FROM_CRYPTO_ONLY(6001)
   * WITHDRAWAL_FROM_WALLET_TO_CRYPTO(6002)
   * SOURCE_WALLET_CURRENCY_DIFFERENT_THAN_DESTINATION_TOKEN_CURRENCY(6003)
   */
  @JsonProperty("code")
  @Override
  public Optional<Integer> getCode() {
    return code;
  }

  @JsonProperty("errors")
  public Optional<List<String>> getErrors() {
    return errors;
  }

  @Override
  public boolean equals(Object other) {
    if (this == other) return true;
    return other instanceof InvalidRequestError && equalTo((InvalidRequestError) other);
  }

  @JsonAnyGetter
  public Map<String, Object> getAdditionalProperties() {
    return this.additionalProperties;
  }

  private boolean equalTo(InvalidRequestError other) {
    return type.equals(other.type) && code.equals(other.code) && errors.equals(other.errors);
  }

  @Override
  public int hashCode() {
    return Objects.hash(this.type, this.code, this.errors);
  }

  @Override
  public String toString() {
    return ObjectMappers.stringify(this);
  }

  public static Builder builder() {
    return new Builder();
  }

  @JsonIgnoreProperties(
      ignoreUnknown = true
  )
  public static final class Builder {
    private Optional<ErrorType> type = Optional.empty();

    private Optional<Integer> code = Optional.empty();

    private Optional<List<String>> errors = Optional.empty();

    @JsonAnySetter
    private Map<String, Object> additionalProperties = new HashMap<>();

    private Builder() {
    }

    public Builder from(InvalidRequestError other) {
      type(other.getType());
      code(other.getCode());
      errors(other.getErrors());
      return this;
    }

    @JsonSetter(
        value = "type",
        nulls = Nulls.SKIP
    )
    public Builder type(Optional<ErrorType> type) {
      this.type = type;
      return this;
    }

    public Builder type(ErrorType type) {
      this.type = Optional.ofNullable(type);
      return this;
    }

    @JsonSetter(
        value = "code",
        nulls = Nulls.SKIP
    )
    public Builder code(Optional<Integer> code) {
      this.code = code;
      return this;
    }

    public Builder code(Integer code) {
      this.code = Optional.ofNullable(code);
      return this;
    }

    @JsonSetter(
        value = "errors",
        nulls = Nulls.SKIP
    )
    public Builder errors(Optional<List<String>> errors) {
      this.errors = errors;
      return this;
    }

    public Builder errors(List<String> errors) {
      this.errors = Optional.ofNullable(errors);
      return this;
    }

    public InvalidRequestError build() {
      return new InvalidRequestError(type, code, errors, additionalProperties);
    }
  }
}
